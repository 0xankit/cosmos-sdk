package registry

import (
	"compress/gzip"
	"embed"
	"fmt"
	"io"

	cosmos_proto "github.com/cosmos/cosmos-proto"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"

	"google.golang.org/protobuf/types/dynamicpb"

	"google.golang.org/protobuf/reflect/protodesc"
	"google.golang.org/protobuf/reflect/protoregistry"

	"google.golang.org/protobuf/reflect/protoreflect"
)

type Registry interface {
	protodesc.Resolver
	protoregistry.MessageTypeResolver
	protoregistry.ExtensionTypeResolver

	// ListAllInterfaces list the type URLs of all registered interfaces.
	ListAllInterfaces() []string

	// ListImplementations lists the valid type URLs for the given interface name that can be used
	// for the provided interface type URL.
	ListImplementations(ifaceTypeURL string) []string

	ListAllModules() []string

	ListModuleFiles(module string) []string

	private()
}

type Registrar interface {
	// ModuleRegistrar gets a ModuleRegistrar instance to register files to
	// be owned by a specific module.
	ModuleRegistrar(module string) ModuleRegistrar

	// Build performs validation of proto files builds a registry instance.
	Build() (Registry, error)

	private()
}

// ModuleRegistrar defines an interface which modules use to register proto files
// that they "own". A proto file owned by a module gives that module special
// permissions to types defined in that file.
type ModuleRegistrar interface {

	// RegisterFiles registers the protobuf file descriptors for a module. pinnedProtoImageFS should
	// be an embedded FS which contains a file - image.bin.gz - generated by buf build, that contains
	// the pinned FileDescriptorSet that this module was built against. This pinned FileDescriptorSet
	// will be used when performing unknown field rejection for correct API compatibility. The
	// file descriptors also passed into RegisterFiles are the protobuf files that the module
	// "owns" and should define relevant Msg and Query servers as well as ORM tables. Instead of
	// using the file descriptors passed in at runtime, RegisterFiles will used the same versions
	// of those file descriptors stored in the pinned FileDescriptorSet, in case the binary for
	// a module was compiled with a newer build of the proto files that the module was developed against.
	// This feature will eventually allow a single binary to contain multiple versions of the same module
	// and perform upgrades without a restart.
	RegisterFiles(pinnedProtoImageFS embed.FS, fileDescriptors ...protoreflect.FileDescriptor) error

	private()
}

func NewRegistrar() Registrar {
	return &registry{
		files:        &protoregistry.Files{},
		moduleFiles:  map[string][]protoreflect.FileDescriptor{},
		interfaceMap: map[string]map[protoreflect.FullName]bool{},
	}
}

type registry struct {
	files        *protoregistry.Files
	moduleFiles  map[string][]protoreflect.FileDescriptor
	interfaceMap map[string]map[protoreflect.FullName]bool
}

func (r *registry) ListAllModules() []string {
	//TODO implement me
	panic("implement me")
}

func (r *registry) ListModuleFiles(module string) []string {
	//TODO implement me
	panic("implement me")
}

func (r *registry) ListAllInterfaces() []string {
	//TODO implement me
	panic("implement me")
}

func (r *registry) ListImplementations(ifaceTypeURL string) []string {
	//TODO implement me
	panic("implement me")
}

func (r *registry) ModuleRegistrar(module string) ModuleRegistrar {
	return &moduleRegistrar{
		registry:   r,
		moduleName: module,
	}
}

func (r *registry) Build() (Registry, error) {
	return r, nil
}

func (r registry) FindFileByPath(s string) (protoreflect.FileDescriptor, error) {
	return r.files.FindFileByPath(s)
}

func (r registry) FindDescriptorByName(name protoreflect.FullName) (protoreflect.Descriptor, error) {
	return r.files.FindDescriptorByName(name)
}

func (r registry) FindMessageByName(fullName protoreflect.FullName) (protoreflect.MessageType, error) {
	typ, err := protoregistry.GlobalTypes.FindMessageByName(fullName)
	if err != nil {
		desc, err := r.FindDescriptorByName(fullName)
		if err != nil {
			return nil, err
		}

		msgDesc, ok := desc.(protoreflect.MessageDescriptor)
		if !ok {
			return nil, fmt.Errorf("%s is not a message name", fullName)
		}

		return dynamicpb.NewMessageType(msgDesc), nil

	}

	return typ, nil
}

func (r registry) FindMessageByURL(url string) (protoreflect.MessageType, error) {
	// this breaks the official proto spec by rejecting URLs which prepend some useless
	// domain name to the type URL
	if url == "" || url[0] != '/' {
		return nil, fmt.Errorf("invalid type URL %s", url)
	}
	return r.FindMessageByName(protoreflect.FullName(url[1:]))
}

func (r registry) FindExtensionByName(field protoreflect.FullName) (protoreflect.ExtensionType, error) {
	typ, err := protoregistry.GlobalTypes.FindExtensionByName(field)
	if err != nil {
		desc, err := r.FindDescriptorByName(field)
		if err != nil {
			return nil, err
		}

		extDesc, ok := desc.(protoreflect.ExtensionDescriptor)
		if !ok {
			return nil, fmt.Errorf("%s is not an extension name", field)
		}

		return dynamicpb.NewExtensionType(extDesc), nil

	}

	return typ, nil
}

func (r registry) FindExtensionByNumber(message protoreflect.FullName, field protoreflect.FieldNumber) (protoreflect.ExtensionType, error) {
	return protoregistry.GlobalTypes.FindExtensionByNumber(message, field)
}

func (r *registry) registerMessages(messages protoreflect.MessageDescriptors) {
	n := messages.Len()
	for i := 0; i < n; i++ {
		msg := messages.Get(i)

		implementsInterface := proto.GetExtension(msg.Options(), cosmos_proto.E_ImplementsInterface).([]string)
		for _, iface := range implementsInterface {
			m, ok := r.interfaceMap[iface]
			if !ok {
				m = map[protoreflect.FullName]bool{}
				r.interfaceMap[iface] = m
			}

			m[msg.FullName()] = true
		}

		r.registerMessages(msg.Messages())
	}
}

func (r registry) private() {}

var _ Registry = &registry{}

type moduleRegistrar struct {
	*registry
	moduleName string
}

func (m moduleRegistrar) RegisterFiles(pinnedProtoImageFS embed.FS, fileDescriptors ...protoreflect.FileDescriptor) error {
	// read the pinned FileDescriptorSet
	f, err := pinnedProtoImageFS.Open("image.bin.gz")
	if err != nil {
		return err
	}

	rdr, err := gzip.NewReader(f)
	if err != nil {
		return err
	}

	bz, err := io.ReadAll(rdr)
	if err != nil {
		return err
	}

	var fdSet descriptorpb.FileDescriptorSet
	err = proto.Unmarshal(bz, &fdSet)
	if err != nil {
		return err
	}

	files, err := protodesc.NewFiles(&fdSet)
	if err != nil {
		return err
	}

	pinnedDescriptors := make([]protoreflect.FileDescriptor, len(fileDescriptors))
	for i, descriptor := range fileDescriptors {
		desc, err := files.FindFileByPath(descriptor.Path())
		if err != nil {
			return err
		}

		pinnedDescriptors[i] = desc
		err = m.files.RegisterFile(desc)
		if err != nil {
			return err
		}

		m.registerMessages(desc.Messages())
	}

	m.moduleFiles[m.moduleName] = pinnedDescriptors

	return nil
}

var _ ModuleRegistrar = &moduleRegistrar{}
