// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/orm/v1alpha1/orm.proto

package ormv1alpha1

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TableDescriptor describes an ORM table.
type TableDescriptor struct {
	// primary_key defines the primary key for the table.
	PrimaryKey *PrimaryKeyDescriptor `protobuf:"bytes,1,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
	// index defines one or more secondary indexes.
	Index []*SecondaryIndexDescriptor `protobuf:"bytes,2,rep,name=index,proto3" json:"index,omitempty"`
	// id is a non-zero integer ID that must be unique within the
	// tables and singletons in this file. It may be deprecated in the future when this
	// can be auto-generated.
	Id uint32 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *TableDescriptor) Reset()         { *m = TableDescriptor{} }
func (m *TableDescriptor) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor) ProtoMessage()    {}
func (*TableDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_65ddfb9b94b23a04, []int{0}
}
func (m *TableDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDescriptor.Merge(m, src)
}
func (m *TableDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *TableDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_TableDescriptor proto.InternalMessageInfo

func (m *TableDescriptor) GetPrimaryKey() *PrimaryKeyDescriptor {
	if m != nil {
		return m.PrimaryKey
	}
	return nil
}

func (m *TableDescriptor) GetIndex() []*SecondaryIndexDescriptor {
	if m != nil {
		return m.Index
	}
	return nil
}

func (m *TableDescriptor) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

// PrimaryKeyDescriptor describes a table primary key.
type PrimaryKeyDescriptor struct {
	// fields is a comma-separated list of fields in the primary key. Spaces are
	// not allowed. Supported field types, their encodings, and any applicable constraints
	// are described below.
	//   - uint32, uint64 are encoded as big-endian fixed width bytes and support
	//   sorted iteration.
	//   - string's are encoded as raw bytes in terminal key segments and null-terminated
	//   in non-terminal segments. Null characters are thus forbidden in strings.
	//   string fields support sorted iteration.
	//   - bytes are encoded as raw bytes in terminal segments and length-prefixed
	//   with a single byte in non-terminal segments. Because of this byte arrays
	//   longer than 255 bytes are unsupported and bytes fields should not
	//   be assumed to be lexically sorted. If you have a byte array longer than
	//   255 bytes that you'd like to index, you should consider hashing it first.
	//   - int32, sint32, int64, sint64 are encoding as fixed width bytes with
	//   an encoding that enables sorted iteration.
	//   - google.protobuf.Timestamp and google.protobuf.Duration are encoded
	//   as 12 bytes using an encoding that enables sorted iteration.
	//   - enum fields are encoded using varint encoding and do not support sorted
	//   iteration.
	//   - bool fields are encoded as a single byte 0 or 1.
	//
	// All other fields types are unsupported in keys including repeated and
	// oneof fields.
	//
	// Primary keys are prefixed by the varint encoded table id and the byte 0x0
	// plus any additional prefix specified by the schema.
	Fields string `protobuf:"bytes,1,opt,name=fields,proto3" json:"fields,omitempty"`
	// auto_increment specifies that the primary key is generated by an
	// auto-incrementing integer. If this is set to true fields must only
	// contain one field of that is of type uint64.
	AutoIncrement bool `protobuf:"varint,2,opt,name=auto_increment,json=autoIncrement,proto3" json:"auto_increment,omitempty"`
	// references specifies that this primary key references the primary key
	// of another table. See the documentation for the SecondaryIndexDescriptor.references
	// field for more details. An additional constraint placed on primary keys
	// which reference another table is that those references cannot be circular.
	References string `protobuf:"bytes,3,opt,name=references,proto3" json:"references,omitempty"`
}

func (m *PrimaryKeyDescriptor) Reset()         { *m = PrimaryKeyDescriptor{} }
func (m *PrimaryKeyDescriptor) String() string { return proto.CompactTextString(m) }
func (*PrimaryKeyDescriptor) ProtoMessage()    {}
func (*PrimaryKeyDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_65ddfb9b94b23a04, []int{1}
}
func (m *PrimaryKeyDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrimaryKeyDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrimaryKeyDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrimaryKeyDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrimaryKeyDescriptor.Merge(m, src)
}
func (m *PrimaryKeyDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *PrimaryKeyDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_PrimaryKeyDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_PrimaryKeyDescriptor proto.InternalMessageInfo

func (m *PrimaryKeyDescriptor) GetFields() string {
	if m != nil {
		return m.Fields
	}
	return ""
}

func (m *PrimaryKeyDescriptor) GetAutoIncrement() bool {
	if m != nil {
		return m.AutoIncrement
	}
	return false
}

func (m *PrimaryKeyDescriptor) GetReferences() string {
	if m != nil {
		return m.References
	}
	return ""
}

// PrimaryKeyDescriptor describes a table secondary index.
type SecondaryIndexDescriptor struct {
	// fields is a comma-separated list of fields in the index. The supported
	// field types are the same as those for PrimaryKeyDescriptor.fields.
	// Index keys are prefixed by the varint encoded table id and the varint
	// encoded index id plus any additional prefix specified by the schema.
	//
	// In addition the the field segments, non-unique index keys are suffixed with
	// any additional primary key fields not present in the index fields so that the
	// primary key can be reconstructed. Unique indexes instead of being suffixed
	// store the remaining primary key fields in the value..
	Fields string `protobuf:"bytes,1,opt,name=fields,proto3" json:"fields,omitempty"`
	// id is a non-zero integer ID that must be unique within the indexes for this
	// table and less than 32768. It may be deprecated in the future when this can
	// be auto-generated.
	Id uint32 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	// unique specifies that this an unique index.
	Unique bool `protobuf:"varint,3,opt,name=unique,proto3" json:"unique,omitempty"`
	// references specifies that this index references another table defined in the same
	// proto file. Currently references are not support to tables with composite
	// primary keys, therefore fields must reference one field and its type must
	// be the same type as the primary key field of the referenced table.
	// References to tables in defined by different proto files are not supported
	// to avoid tight coupling of dependencies. Beyond validating that the reference
	// is valid key constraints are currently not enforced, but references should
	// be used by clients to perform automatic joins.
	References string `protobuf:"bytes,4,opt,name=references,proto3" json:"references,omitempty"`
}

func (m *SecondaryIndexDescriptor) Reset()         { *m = SecondaryIndexDescriptor{} }
func (m *SecondaryIndexDescriptor) String() string { return proto.CompactTextString(m) }
func (*SecondaryIndexDescriptor) ProtoMessage()    {}
func (*SecondaryIndexDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_65ddfb9b94b23a04, []int{2}
}
func (m *SecondaryIndexDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecondaryIndexDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecondaryIndexDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecondaryIndexDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecondaryIndexDescriptor.Merge(m, src)
}
func (m *SecondaryIndexDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *SecondaryIndexDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_SecondaryIndexDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_SecondaryIndexDescriptor proto.InternalMessageInfo

func (m *SecondaryIndexDescriptor) GetFields() string {
	if m != nil {
		return m.Fields
	}
	return ""
}

func (m *SecondaryIndexDescriptor) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SecondaryIndexDescriptor) GetUnique() bool {
	if m != nil {
		return m.Unique
	}
	return false
}

func (m *SecondaryIndexDescriptor) GetReferences() string {
	if m != nil {
		return m.References
	}
	return ""
}

// TableDescriptor describes an ORM singleton table which has at most one instance.
type SingletonDescriptor struct {
	// id is a non-zero integer ID that must be unique within the
	// tables and singletons in this file. It may be deprecated in the future when this
	// can be auto-generated.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *SingletonDescriptor) Reset()         { *m = SingletonDescriptor{} }
func (m *SingletonDescriptor) String() string { return proto.CompactTextString(m) }
func (*SingletonDescriptor) ProtoMessage()    {}
func (*SingletonDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_65ddfb9b94b23a04, []int{3}
}
func (m *SingletonDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SingletonDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SingletonDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SingletonDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SingletonDescriptor.Merge(m, src)
}
func (m *SingletonDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *SingletonDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_SingletonDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_SingletonDescriptor proto.InternalMessageInfo

func (m *SingletonDescriptor) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

var E_Table = &proto.ExtensionDesc{
	ExtendedType:  (*descriptorpb.MessageOptions)(nil),
	ExtensionType: (*TableDescriptor)(nil),
	Field:         104503790,
	Name:          "cosmos.orm.v1alpha1.table",
	Tag:           "bytes,104503790,opt,name=table",
	Filename:      "cosmos/orm/v1alpha1/orm.proto",
}

var E_Singleton = &proto.ExtensionDesc{
	ExtendedType:  (*descriptorpb.MessageOptions)(nil),
	ExtensionType: (*SingletonDescriptor)(nil),
	Field:         104503791,
	Name:          "cosmos.orm.v1alpha1.singleton",
	Tag:           "bytes,104503791,opt,name=singleton",
	Filename:      "cosmos/orm/v1alpha1/orm.proto",
}

func init() {
	proto.RegisterType((*TableDescriptor)(nil), "cosmos.orm.v1alpha1.TableDescriptor")
	proto.RegisterType((*PrimaryKeyDescriptor)(nil), "cosmos.orm.v1alpha1.PrimaryKeyDescriptor")
	proto.RegisterType((*SecondaryIndexDescriptor)(nil), "cosmos.orm.v1alpha1.SecondaryIndexDescriptor")
	proto.RegisterType((*SingletonDescriptor)(nil), "cosmos.orm.v1alpha1.SingletonDescriptor")
	proto.RegisterExtension(E_Table)
	proto.RegisterExtension(E_Singleton)
}

func init() { proto.RegisterFile("cosmos/orm/v1alpha1/orm.proto", fileDescriptor_65ddfb9b94b23a04) }

var fileDescriptor_65ddfb9b94b23a04 = []byte{
	// 525 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x53, 0x4f, 0x6f, 0xd3, 0x30,
	0x1c, 0xad, 0x53, 0x36, 0xb5, 0xae, 0x36, 0xa4, 0x94, 0x3f, 0x11, 0x12, 0x59, 0x55, 0x31, 0xa9,
	0x1c, 0x96, 0xa8, 0xe3, 0x16, 0x6e, 0x2d, 0x12, 0x1a, 0x30, 0xa5, 0xca, 0x10, 0x42, 0xa8, 0x62,
	0x72, 0x13, 0xb7, 0x33, 0x8b, 0xe3, 0x60, 0x3b, 0x88, 0xf0, 0x29, 0xf8, 0x0c, 0x1c, 0x39, 0xc2,
	0x97, 0x40, 0x9c, 0x76, 0xe4, 0x88, 0xda, 0xdb, 0x0e, 0x70, 0xe4, 0x8a, 0x12, 0xd7, 0x5b, 0xb5,
	0x65, 0xda, 0xa9, 0xf5, 0xfb, 0xbd, 0xdf, 0x7b, 0x2f, 0x79, 0x31, 0xbc, 0x1f, 0x32, 0x41, 0x99,
	0x70, 0x19, 0xa7, 0xee, 0x87, 0x3e, 0x8a, 0xd3, 0x23, 0xd4, 0x2f, 0x0e, 0x4e, 0xca, 0x99, 0x64,
	0x66, 0x5b, 0x8d, 0x9d, 0x02, 0xd1, 0xe3, 0x7b, 0x9d, 0x19, 0x63, 0xb3, 0x18, 0xbb, 0x25, 0x65,
	0x92, 0x4d, 0xdd, 0x08, 0x8b, 0x90, 0x93, 0x54, 0x32, 0xae, 0xd6, 0xba, 0xdf, 0x00, 0xbc, 0xf9,
	0x12, 0x4d, 0x62, 0xfc, 0xe4, 0x6c, 0x62, 0x3e, 0x83, 0xad, 0x94, 0x13, 0x8a, 0x78, 0x7e, 0x78,
	0x8c, 0x73, 0x0b, 0x74, 0x40, 0xaf, 0xb5, 0xfb, 0xd0, 0xa9, 0x30, 0x70, 0x46, 0x8a, 0xf7, 0x1c,
	0xe7, 0xe7, 0xfb, 0x01, 0x4c, 0xcf, 0x50, 0x73, 0x08, 0xd7, 0x48, 0x12, 0xe1, 0x8f, 0x96, 0xd1,
	0xa9, 0xf7, 0x5a, 0xbb, 0x3b, 0x95, 0x2a, 0x07, 0x38, 0x64, 0x49, 0x84, 0x78, 0xbe, 0x57, 0x50,
	0x57, 0x94, 0xd4, 0xae, 0xb9, 0x09, 0x0d, 0x12, 0x59, 0xf5, 0x0e, 0xe8, 0x6d, 0x04, 0x06, 0x89,
	0xba, 0x19, 0xbc, 0x55, 0x65, 0x6c, 0xde, 0x81, 0xeb, 0x53, 0x82, 0xe3, 0x48, 0x94, 0x99, 0x9b,
	0xc1, 0xf2, 0x64, 0x6e, 0xc3, 0x4d, 0x94, 0x49, 0x76, 0x48, 0x92, 0x90, 0x63, 0x8a, 0x13, 0x69,
	0x19, 0x1d, 0xd0, 0x6b, 0x04, 0x1b, 0x05, 0xba, 0xa7, 0x41, 0xd3, 0x86, 0x90, 0xe3, 0x29, 0xe6,
	0x38, 0x09, 0xb1, 0x28, 0xed, 0x9a, 0xc1, 0x0a, 0xd2, 0xfd, 0x04, 0xad, 0xab, 0x92, 0x5e, 0x69,
	0xad, 0xa2, 0x1b, 0x3a, 0x7a, 0xc1, 0xcb, 0x12, 0xf2, 0x3e, 0xc3, 0xa5, 0x7e, 0x23, 0x58, 0x9e,
	0x2e, 0x78, 0xdf, 0xb8, 0xe4, 0xbd, 0x0d, 0xdb, 0x07, 0x24, 0x99, 0xc5, 0x58, 0xb2, 0x64, 0xc5,
	0x56, 0xc9, 0x03, 0x2d, 0xef, 0xbd, 0x85, 0x6b, 0xb2, 0x68, 0xd3, 0xdc, 0x72, 0x54, 0xf5, 0x8e,
	0xae, 0xde, 0xd9, 0xc7, 0x42, 0xa0, 0x19, 0xf6, 0x53, 0x49, 0x58, 0x22, 0xac, 0x3f, 0xdf, 0x4f,
	0xfb, 0x65, 0xb1, 0x0f, 0x2a, 0x2b, 0xb9, 0xf0, 0x4d, 0x04, 0x4a, 0xd6, 0x7b, 0x07, 0x9b, 0x42,
	0xc7, 0xb8, 0xde, 0xe3, 0xaf, 0xf6, 0xe8, 0x55, 0xd7, 0x7e, 0xf9, 0x81, 0x82, 0x73, 0xf9, 0xc1,
	0x3f, 0xf0, 0x63, 0x6e, 0x83, 0x93, 0xb9, 0x0d, 0x7e, 0xcf, 0x6d, 0xf0, 0x79, 0x61, 0xd7, 0x4e,
	0x16, 0x76, 0xed, 0xd7, 0xc2, 0xae, 0xc1, 0xbb, 0x21, 0xa3, 0x55, 0x92, 0x83, 0x86, 0xcf, 0xe9,
	0xa8, 0x48, 0x33, 0x02, 0x6f, 0x5e, 0xcc, 0x88, 0x3c, 0xca, 0x26, 0x4e, 0xc8, 0xa8, 0xbb, 0xbc,
	0x3b, 0xea, 0x67, 0x47, 0x44, 0xc7, 0xae, 0xcc, 0x53, 0x2c, 0x5c, 0x94, 0x92, 0x90, 0xd1, 0x14,
	0x49, 0xb7, 0xe2, 0x76, 0x3d, 0x66, 0x9c, 0xea, 0xff, 0x5f, 0x8c, 0xfa, 0xd0, 0x7f, 0xfd, 0xd5,
	0x68, 0x0f, 0x95, 0xab, 0xcf, 0xa9, 0xf3, 0x6a, 0x39, 0xfb, 0xa9, 0xd1, 0xb1, 0xcf, 0xe9, 0x58,
	0xa3, 0x73, 0x63, 0xab, 0x02, 0x1d, 0x3f, 0x1d, 0x0d, 0xf6, 0xb1, 0x44, 0x11, 0x92, 0xe8, 0xd4,
	0xb8, 0xad, 0x18, 0x9e, 0xe7, 0x73, 0xea, 0x79, 0x9a, 0x33, 0x59, 0x2f, 0x5f, 0xe8, 0xa3, 0xff,
	0x01, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x94, 0x8e, 0xb1, 0xf3, 0x03, 0x00, 0x00,
}

func (m *TableDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintOrm(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Index) > 0 {
		for iNdEx := len(m.Index) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Index[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOrm(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PrimaryKey != nil {
		{
			size, err := m.PrimaryKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOrm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrimaryKeyDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimaryKeyDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrimaryKeyDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.References) > 0 {
		i -= len(m.References)
		copy(dAtA[i:], m.References)
		i = encodeVarintOrm(dAtA, i, uint64(len(m.References)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AutoIncrement {
		i--
		if m.AutoIncrement {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Fields) > 0 {
		i -= len(m.Fields)
		copy(dAtA[i:], m.Fields)
		i = encodeVarintOrm(dAtA, i, uint64(len(m.Fields)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecondaryIndexDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecondaryIndexDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecondaryIndexDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.References) > 0 {
		i -= len(m.References)
		copy(dAtA[i:], m.References)
		i = encodeVarintOrm(dAtA, i, uint64(len(m.References)))
		i--
		dAtA[i] = 0x22
	}
	if m.Unique {
		i--
		if m.Unique {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i = encodeVarintOrm(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Fields) > 0 {
		i -= len(m.Fields)
		copy(dAtA[i:], m.Fields)
		i = encodeVarintOrm(dAtA, i, uint64(len(m.Fields)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SingletonDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SingletonDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SingletonDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintOrm(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintOrm(dAtA []byte, offset int, v uint64) int {
	offset -= sovOrm(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TableDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrimaryKey != nil {
		l = m.PrimaryKey.Size()
		n += 1 + l + sovOrm(uint64(l))
	}
	if len(m.Index) > 0 {
		for _, e := range m.Index {
			l = e.Size()
			n += 1 + l + sovOrm(uint64(l))
		}
	}
	if m.Id != 0 {
		n += 1 + sovOrm(uint64(m.Id))
	}
	return n
}

func (m *PrimaryKeyDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fields)
	if l > 0 {
		n += 1 + l + sovOrm(uint64(l))
	}
	if m.AutoIncrement {
		n += 2
	}
	l = len(m.References)
	if l > 0 {
		n += 1 + l + sovOrm(uint64(l))
	}
	return n
}

func (m *SecondaryIndexDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fields)
	if l > 0 {
		n += 1 + l + sovOrm(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovOrm(uint64(m.Id))
	}
	if m.Unique {
		n += 2
	}
	l = len(m.References)
	if l > 0 {
		n += 1 + l + sovOrm(uint64(l))
	}
	return n
}

func (m *SingletonDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOrm(uint64(m.Id))
	}
	return n
}

func sovOrm(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOrm(x uint64) (n int) {
	return sovOrm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TableDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrimaryKey == nil {
				m.PrimaryKey = &PrimaryKeyDescriptor{}
			}
			if err := m.PrimaryKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOrm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append(m.Index, &SecondaryIndexDescriptor{})
			if err := m.Index[len(m.Index)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimaryKeyDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimaryKeyDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimaryKeyDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoIncrement", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoIncrement = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.References = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecondaryIndexDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecondaryIndexDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecondaryIndexDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unique = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOrm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOrm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.References = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOrm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingletonDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOrm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingletonDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingletonDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOrm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOrm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOrm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOrm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOrm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOrm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOrm
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOrm
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOrm
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOrm        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOrm          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOrm = fmt.Errorf("proto: unexpected end of group")
)
